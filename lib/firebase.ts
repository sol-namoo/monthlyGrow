// src/lib/firebase.ts

import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";
import {
  getAuth,
  GoogleAuthProvider,
  setPersistence,
  browserLocalPersistence,
  updateProfile,
} from "firebase/auth";
import {
  collection,
  doc,
  getDoc,
  getDocs,
  query,
  where,
  addDoc,
  updateDoc,
  setDoc,
  deleteDoc,
  Timestamp,
  writeBatch,
  orderBy,
  startAfter,
  limit,
} from "firebase/firestore";
import {
  ref,
  uploadBytes,
  getDownloadURL,
  deleteObject,
} from "firebase/storage";
import {
  Area,
  Resource,
  Project,
  Task,
  Chapter,
  Retrospective,
  Note,
  User,
  UserProfile,
  UserSettings,
  UserPreferences,
} from "./types"; // lib/types.tsÏóêÏÑú ÌÉÄÏûÖ import
import { getChapterStatus } from "./utils";

const firebaseConfig = {
  apiKey: "AIzaSyCKEG-VqAZRGyEpSsPIxeJV5ACZ8mfQvPY",
  authDomain: "monthlygrow-cb74d.firebaseapp.com",
  projectId: "monthlygrow-cb74d",
  storageBucket: "monthlygrow-cb74d.firebasestorage.app",
  messagingSenderId: "960277815712",
  appId: "1:960277815712:web:38f547540231380e0fc4c5",
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);

// Initialize Firestore
export const db = getFirestore(app);

// Initialize Auth
export const auth = getAuth(app);
export const googleAuthProvider = new GoogleAuthProvider();

// Initialize Storage
export const storage = getStorage(app);

// Set persistence to LOCAL (localStorage)
setPersistence(auth, browserLocalPersistence).catch((error) => {
  console.error("Auth persistence ÏÑ§Ï†ï Ïã§Ìå®:", error);
});

// --- Utility Functions ---

// Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± Ïãú ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ ÏÑ§Ï†ï Ïú†Ìã∏Î¶¨Ìã∞
export const createTimestamp = () => Timestamp.now();

// Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± Ïãú Í∏∞Î≥∏ ÌïÑÎìú ÏÑ§Ï†ï
export const createBaseData = (userId: string) => ({
  userId,
  createdAt: createTimestamp(),
  updatedAt: createTimestamp(), // ÏÉùÏÑ± ÏãúÏóêÎäî createdAtÍ≥º ÎèôÏùº
});

// Îç∞Ïù¥ÌÑ∞ ÏàòÏ†ï Ïãú updatedAt ÌïÑÎìú ÏóÖÎç∞Ïù¥Ìä∏
export const updateTimestamp = () => Timestamp.now();

// Task Ï†ïÎ†¨ Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
const sortTasksByDateAndTitle = (tasks: Task[]): Task[] => {
  return tasks.sort((a, b) => {
    const dateA = new Date(a.date);
    const dateB = new Date(b.date);

    // Date ÎπÑÍµê
    if (dateA.getTime() !== dateB.getTime()) {
      return dateA.getTime() - dateB.getTime();
    }

    // Í∞ôÏùÄ dateÏù∏ Í≤ΩÏö∞ Ï†úÎ™©ÏúºÎ°ú Ï†ïÎ†¨
    return a.title.localeCompare(b.title);
  });
};

// --- Basic Data Fetching Functions ---

// Areas
export const fetchAllAreasByUserId = async (
  userId: string
): Promise<Area[]> => {
  const q = query(collection(db, "areas"), where("userId", "==", userId));
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Area;
  });
};

export const fetchActiveAreasByUserId = async (
  userId: string
): Promise<Area[]> => {
  const q = query(
    collection(db, "areas"),
    where("userId", "==", userId),
    where("status", "==", "active")
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => ({
    id: doc.id,
    ...doc.data(),
  })) as Area[];
};

export const fetchArchivedAreasByUserId = async (
  userId: string
): Promise<Area[]> => {
  const q = query(
    collection(db, "areas"),
    where("userId", "==", userId),
    where("status", "==", "archived")
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => ({
    id: doc.id,
    ...doc.data(),
  })) as Area[];
};

export const fetchAreaById = async (areaId: string): Promise<Area> => {
  const docRef = doc(db, "areas", areaId);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    const data = docSnap.data();
    return {
      id: docSnap.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Area;
  } else {
    throw new Error("Area not found");
  }
};

// Resources
export const fetchAllResourcesByUserId = async (
  userId: string
): Promise<Resource[]> => {
  const q = query(collection(db, "resources"), where("userId", "==", userId));
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Resource;
  });
};

export const fetchActiveResourcesByUserId = async (
  userId: string
): Promise<Resource[]> => {
  const q = query(
    collection(db, "resources"),
    where("userId", "==", userId),
    where("status", "==", "active")
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => ({
    id: doc.id,
    ...doc.data(),
  })) as Resource[];
};

export const fetchArchivedResourcesByUserId = async (
  userId: string
): Promise<Resource[]> => {
  const q = query(
    collection(db, "resources"),
    where("userId", "==", userId),
    where("status", "==", "archived")
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => ({
    id: doc.id,
    ...doc.data(),
  })) as Resource[];
};

export const fetchResourceById = async (
  resourceId: string
): Promise<Resource> => {
  const docRef = doc(db, "resources", resourceId);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    const data = docSnap.data();
    return {
      id: docSnap.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Resource;
  } else {
    throw new Error("Resource not found");
  }
};

// Î¶¨ÏÜåÏä§ÏôÄ Ïó∞Í≤∞Îêú ÏòÅÏó≠ Ï†ïÎ≥¥Î•º Ìï®Íªò Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
export const fetchResourceWithAreaById = async (
  resourceId: string
): Promise<Resource & { area?: { id: string; name: string } }> => {
  const docRef = doc(db, "resources", resourceId);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    const data = docSnap.data();
    const resource = {
      id: docSnap.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Resource;

    // ÏòÅÏó≠ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    if (resource.areaId) {
      try {
        const areaRef = doc(db, "areas", resource.areaId);
        const areaSnap = await getDoc(areaRef);
        if (areaSnap.exists()) {
          const areaData = areaSnap.data();
          return {
            ...resource,
            area: {
              id: areaSnap.id,
              name: areaData.name || "Í∏∞ÌÉÄ",
            },
          } as Resource & { area?: { id: string; name: string } };
        }
      } catch (error) {
        console.error("Error fetching area for resource:", error);
      }
    }

    return resource as Resource & { area?: { id: string; name: string } };
  } else {
    throw new Error("Resource not found");
  }
};

// Projects
export const fetchAllProjectsByUserId = async (
  userId: string
): Promise<Project[]> => {
  const q = query(collection(db, "projects"), where("userId", "==", userId));
  const querySnapshot = await getDocs(q);

  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate?.toDate(),
      endDate: data.endDate?.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedChapters: data.connectedChapters || [],
    } as Project;
  });
};

export const fetchActiveProjectsByUserId = async (
  userId: string
): Promise<Project[]> => {
  const q = query(
    collection(db, "projects"),
    where("userId", "==", userId),
    where("status", "==", "active")
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate?.toDate(),
      endDate: data.endDate?.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedChapters: data.connectedChapters || [],
    } as Project;
  });
};

export const fetchArchivedProjectsByUserId = async (
  userId: string
): Promise<Project[]> => {
  const q = query(
    collection(db, "projects"),
    where("userId", "==", userId),
    where("status", "==", "archived")
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate?.toDate(),
      endDate: data.endDate?.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedChapters: data.connectedChapters || [],
    } as Project;
  });
};

export const fetchProjectById = async (projectId: string): Promise<Project> => {
  console.log("üî• Firestore: Fetching project by ID:", projectId);
  const docRef = doc(db, "projects", projectId);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    const data = docSnap.data();
    const project = {
      id: docSnap.id,
      ...data,
      startDate: data.startDate.toDate(),
      endDate: data.endDate.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedChapters: data.connectedChapters || [],
    } as Project;

    console.log("üî• Firestore: Project data:", {
      id: project.id,
      title: project.title,
      target: project.target,
      category: project.category,
      area: project.area,
    });

    return project;
  } else {
    throw new Error("Project not found");
  }
};

export const fetchProjectsByAreaId = async (
  areaId: string
): Promise<Project[]> => {
  const q = query(collection(db, "projects"), where("areaId", "==", areaId));
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate?.toDate(),
      endDate: data.endDate?.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedChapters: data.connectedChapters || [],
    } as Project;
  });
};

export const fetchProjectsByChapterId = async (
  chapterId: string,
  userId?: string
): Promise<Project[]> => {
  // userIdÍ∞Ä ÏóÜÏúºÎ©¥ chapterIdÏóêÏÑú Ï∂îÏ∂ú ÏãúÎèÑ
  const targetUserId = userId || chapterId.split("_")[0];

  // Î™®Îì† ÌîÑÎ°úÏ†ùÌä∏Î•º Í∞ÄÏ†∏Ïò® ÌõÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÇ¨Ïù¥ÎìúÏóêÏÑú ÌïÑÌÑ∞ÎßÅ
  const q = query(
    collection(db, "projects"),
    where("userId", "==", targetUserId)
  );

  const querySnapshot = await getDocs(q);
  const projects = querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate?.toDate(),
      endDate: data.endDate?.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedChapters: data.connectedChapters || [],
    } as Project;
  });

  // connectedChapters Î∞∞Ïó¥ ÎòêÎäî chapterId ÌïÑÎìúÏóêÏÑú Ìï¥Îãπ chapterIdÎ•º Í∞ÄÏßÑ ÌîÑÎ°úÏ†ùÌä∏Îì§Îßå ÌïÑÌÑ∞ÎßÅ
  return projects.filter((project) => {
    const connectedChapters = (project as any).connectedChapters || [];
    return (
      connectedChapters.includes(chapterId) || project.chapterId === chapterId
    );
  });
};

// ÌòÑÏû¨ Ï±ïÌÑ∞Ïùò ÌîÑÎ°úÏ†ùÌä∏Îßå Ìö®Ïú®Ï†ÅÏúºÎ°ú Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
export const fetchCurrentChapterProjects = async (
  userId: string,
  currentChapterId?: string
): Promise<Project[]> => {
  if (!currentChapterId) return [];

  // ÌòÑÏû¨ Ï±ïÌÑ∞Ïóê Ïó∞Í≤∞Îêú ÌîÑÎ°úÏ†ùÌä∏Îì§Îßå Í∞ÄÏ†∏Ïò§Í∏∞
  const q = query(collection(db, "projects"), where("userId", "==", userId));

  const querySnapshot = await getDocs(q);
  const projects = querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate?.toDate(),
      endDate: data.endDate?.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedChapters: data.connectedChapters || [],
    } as Project;
  });

  // ÌòÑÏû¨ Ï±ïÌÑ∞Ïóê Ïó∞Í≤∞Îêú ÌîÑÎ°úÏ†ùÌä∏Îì§Îßå ÌïÑÌÑ∞ÎßÅ
  return projects.filter((project) => {
    const connectedChapters = (project as any).connectedChapters || [];
    return (
      connectedChapters.includes(currentChapterId) ||
      project.chapterId === currentChapterId
    );
  });
};

// Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùÄ ÌîÑÎ°úÏ†ùÌä∏Îì§Îßå Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò (Ï±ïÌÑ∞ Ìé∏ÏßëÏö©)
export const fetchUnconnectedProjects = async (
  userId: string,
  excludeChapterId?: string
): Promise<Project[]> => {
  const q = query(collection(db, "projects"), where("userId", "==", userId));

  const querySnapshot = await getDocs(q);
  const projects = querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate?.toDate(),
      endDate: data.endDate?.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedChapters: data.connectedChapters || [],
    } as Project;
  });

  // excludeChapterIdÍ∞Ä ÏûàÏúºÎ©¥ Ìï¥Îãπ Ï±ïÌÑ∞Ïóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùÄ ÌîÑÎ°úÏ†ùÌä∏Îì§Îßå Î∞òÌôò
  if (excludeChapterId) {
    return projects.filter((project) => {
      const connectedChapters = (project as any).connectedChapters || [];
      return (
        !connectedChapters.includes(excludeChapterId) &&
        project.chapterId !== excludeChapterId
      );
    });
  }

  // excludeChapterIdÍ∞Ä ÏóÜÏúºÎ©¥ Î™®Îì† ÌîÑÎ°úÏ†ùÌä∏ Î∞òÌôò (Ï±ïÌÑ∞ ÏÉùÏÑ± Ïãú)
  return projects;
};

// Ï±ïÌÑ∞Î≥Ñ ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàòÎßå Ìö®Ïú®Ï†ÅÏúºÎ°ú Ï°∞ÌöåÌïòÎäî Ìï®Ïàò
export const fetchProjectCountsByChapterIds = async (
  chapterIds: string[],
  userId: string
): Promise<{ [chapterId: string]: number }> => {
  if (chapterIds.length === 0) return {};

  const counts: { [chapterId: string]: number } = {};

  console.log("üîç fetchProjectCountsByChapterIds ÏãúÏûë");
  console.log("Ï°∞ÌöåÌï† Ï±ïÌÑ∞ IDs:", chapterIds);
  console.log("ÏÇ¨Ïö©Ïûê ID:", userId);

  // Î™®Îì† ÌîÑÎ°úÏ†ùÌä∏Î•º Ìïú Î≤àÏóê Í∞ÄÏ†∏Ïò§Í∏∞
  const allProjectsQuery = query(
    collection(db, "projects"),
    where("userId", "==", userId)
  );
  const allProjectsSnapshot = await getDocs(allProjectsQuery);
  const allProjects = allProjectsSnapshot.docs.map((doc) => ({
    id: doc.id,
    ...doc.data(),
  })) as Project[];

  console.log(`Ï¥ù ${allProjects.length}Í∞ú ÌîÑÎ°úÏ†ùÌä∏ Ï°∞ÌöåÎê®`);

  // Í∞Å Ï±ïÌÑ∞Î≥ÑÎ°ú ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàò Í≥ÑÏÇ∞
  for (const chapterId of chapterIds) {
    console.log(`\nüìä Ï±ïÌÑ∞ ${chapterId} Í≥ÑÏÇ∞ Ï§ë...`);

    const connectedProjects = allProjects.filter((project) => {
      const connectedChapters = (project as any).connectedChapters || [];
      return (
        connectedChapters.includes(chapterId) || project.chapterId === chapterId
      );
    });

    console.log(
      `Ï±ïÌÑ∞ ${chapterId} Í≤∞Í≥º:`,
      connectedProjects.length,
      "Í∞ú ÌîÑÎ°úÏ†ùÌä∏"
    );

    // Ïã§Ï†ú ÌîÑÎ°úÏ†ùÌä∏ Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
    if (connectedProjects.length > 0) {
      console.log("Ïó∞Í≤∞Îêú ÌîÑÎ°úÏ†ùÌä∏Îì§:");
      connectedProjects.forEach((project) => {
        console.log(
          `- ${project.title}: connectedChapters =`,
          (project as any).connectedChapters
        );
      });
    } else {
      console.log("Ïó∞Í≤∞Îêú ÌîÑÎ°úÏ†ùÌä∏ ÏóÜÏùå");
    }

    counts[chapterId] = connectedProjects.length;
  }

  console.log("ÏµúÏ¢Ö Í≤∞Í≥º:", counts);
  return counts;
};

// Tasks
export const fetchAllTasksByUserId = async (
  userId: string
): Promise<Task[]> => {
  const q = query(collection(db, "tasks"), where("userId", "==", userId));
  const querySnapshot = await getDocs(q);
  const tasks = querySnapshot.docs.map((doc) => ({
    id: doc.id,
    ...doc.data(),
  })) as Task[];

  return sortTasksByDateAndTitle(tasks);
};

export const fetchAllTasksByProjectId = async (
  projectId: string
): Promise<Task[]> => {
  try {
    // ÏÑúÎ∏åÏª¨Î†âÏÖòÏóêÏÑú ÌÉúÏä§ÌÅ¨ Í∞ÄÏ†∏Ïò§Í∏∞
    const tasksRef = collection(db, "projects", projectId, "tasks");
    const querySnapshot = await getDocs(tasksRef);
    const tasks = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    })) as Task[];

    return sortTasksByDateAndTitle(tasks);
  } catch (error) {
    // ÏÑúÎ∏åÏª¨Î†âÏÖòÏóêÏÑú Ïã§Ìå®ÌïòÎ©¥ Î©îÏù∏ Ïª¨Î†âÏÖòÏóêÏÑú ÏãúÎèÑ (fallback)
    const q = query(
      collection(db, "tasks"),
      where("projectId", "==", projectId)
    );
    const querySnapshot = await getDocs(q);
    const tasks = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    })) as Task[];

    return sortTasksByDateAndTitle(tasks);
  }
};

// ÌîÑÎ°úÏ†ùÌä∏Ïùò ÌÉúÏä§ÌÅ¨ Í∞úÏàòÎßå Ïπ¥Ïö¥Ìä∏ÌïòÎäî Ìï®Ïàò
export const getTaskCountsByProjectId = async (
  projectId: string
): Promise<{ totalTasks: number; completedTasks: number }> => {
  try {
    // ÏÑúÎ∏åÏª¨Î†âÏÖòÏóêÏÑú ÌÉúÏä§ÌÅ¨ Í∞úÏàò Í∞ÄÏ†∏Ïò§Í∏∞
    const tasksRef = collection(db, "projects", projectId, "tasks");
    const querySnapshot = await getDocs(tasksRef);

    const totalTasks = querySnapshot.size;
    const completedTasks = querySnapshot.docs.filter(
      (doc) => doc.data().done === true
    ).length;

    return { totalTasks, completedTasks };
  } catch (error) {
    // ÏÑúÎ∏åÏª¨Î†âÏÖòÏóêÏÑú Ïã§Ìå®ÌïòÎ©¥ Î©îÏù∏ Ïª¨Î†âÏÖòÏóêÏÑú ÏãúÎèÑ (fallback)
    const q = query(
      collection(db, "tasks"),
      where("projectId", "==", projectId)
    );
    const querySnapshot = await getDocs(q);

    const totalTasks = querySnapshot.size;
    const completedTasks = querySnapshot.docs.filter(
      (doc) => doc.data().done === true
    ).length;

    return { totalTasks, completedTasks };
  }
};

// Ïó¨Îü¨ ÌîÑÎ°úÏ†ùÌä∏Ïùò ÌÉúÏä§ÌÅ¨ Í∞úÏàòÎ•º Ìïú Î≤àÏóê Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò (Î∞∞Ïπò ÏµúÏ†ÅÌôî)
export const getTaskCountsForMultipleProjects = async (
  projectIds: string[]
): Promise<{
  [projectId: string]: { totalTasks: number; completedTasks: number };
}> => {
  if (projectIds.length === 0) return {};

  console.log("üîç getTaskCountsForMultipleProjects ÏãúÏûë:", { projectIds });

  // ÌîÑÎ°úÏ†ùÌä∏Î≥ÑÎ°ú Í∑∏Î£πÌôî
  const counts: {
    [projectId: string]: { totalTasks: number; completedTasks: number };
  } = {};

  // Ï¥àÍ∏∞Ìôî
  projectIds.forEach((id) => {
    counts[id] = { totalTasks: 0, completedTasks: 0 };
  });

  try {
    // ÏÑúÎ∏åÏª¨Î†âÏÖòÏóêÏÑú Í∞Å ÌîÑÎ°úÏ†ùÌä∏Î≥ÑÎ°ú ÌÉúÏä§ÌÅ¨ Í∞úÏàò Í∞ÄÏ†∏Ïò§Í∏∞
    for (const projectId of projectIds) {
      try {
        const tasksRef = collection(db, "projects", projectId, "tasks");
        const querySnapshot = await getDocs(tasksRef);

        const totalTasks = querySnapshot.size;
        const completedTasks = querySnapshot.docs.filter(
          (doc) => doc.data().done === true
        ).length;

        counts[projectId] = { totalTasks, completedTasks };

        console.log(`üîç ÌîÑÎ°úÏ†ùÌä∏ ${projectId} ÏÑúÎ∏åÏª¨Î†âÏÖò Í≤∞Í≥º:`, {
          totalTasks,
          completedTasks,
          tasksFound: querySnapshot.docs.length,
        });
      } catch (error) {
        console.error(`‚ùå ÌîÑÎ°úÏ†ùÌä∏ ${projectId} ÏÑúÎ∏åÏª¨Î†âÏÖò Ï°∞Ìöå Ïã§Ìå®:`, error);
        // Í∞úÎ≥Ñ ÌîÑÎ°úÏ†ùÌä∏ Ïã§Ìå® Ïãú Í∏∞Î≥∏Í∞í Ïú†ÏßÄ
      }
    }

    console.log("üîç ÏµúÏ¢Ö ÏÑúÎ∏åÏª¨Î†âÏÖò Í≤∞Í≥º:", counts);
    return counts;
  } catch (error) {
    console.error("‚ùå ÏÑúÎ∏åÏª¨Î†âÏÖò Ï†ÑÏ≤¥ Ïã§Ìå®, Î©îÏù∏ Ïª¨Î†âÏÖòÏúºÎ°ú Ìè¥Î∞±:", error);

    // ÏÑúÎ∏åÏª¨Î†âÏÖòÏóêÏÑú Ïã§Ìå®ÌïòÎ©¥ Î©îÏù∏ Ïª¨Î†âÏÖòÏóêÏÑú ÏãúÎèÑ (fallback)
    const q = query(
      collection(db, "tasks"),
      where("projectId", "in", projectIds)
    );
    const querySnapshot = await getDocs(q);

    // Ïπ¥Ïö¥Ìä∏ Í≥ÑÏÇ∞
    querySnapshot.docs.forEach((doc) => {
      const data = doc.data();
      const projectId = data.projectId;
      if (counts[projectId]) {
        counts[projectId].totalTasks++;
        if (data.done === true) {
          counts[projectId].completedTasks++;
        }
      }
    });

    console.log("üîç Î©îÏù∏ Ïª¨Î†âÏÖò Ìè¥Î∞± Í≤∞Í≥º:", counts);
    return counts;
  }
};

// ÌîÑÎ°úÏ†ùÌä∏Ïùò ÏãúÍ∞Ñ ÌÜµÍ≥ÑÎßå Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
export const getTaskTimeStatsByProjectId = async (
  projectId: string
): Promise<{ completedTime: number; remainingTime: number }> => {
  try {
    // ÏÑúÎ∏åÏª¨Î†âÏÖòÏóêÏÑú ÏãúÍ∞Ñ ÌÜµÍ≥Ñ Í∞ÄÏ†∏Ïò§Í∏∞
    const tasksRef = collection(db, "projects", projectId, "tasks");
    const querySnapshot = await getDocs(tasksRef);

    let completedTime = 0;
    let remainingTime = 0;

    querySnapshot.docs.forEach((doc) => {
      const data = doc.data();
      const duration = data.duration || 0;
      if (data.done === true) {
        completedTime += duration;
      } else {
        remainingTime += duration;
      }
    });

    return { completedTime, remainingTime };
  } catch (error) {
    // ÏÑúÎ∏åÏª¨Î†âÏÖòÏóêÏÑú Ïã§Ìå®ÌïòÎ©¥ Î©îÏù∏ Ïª¨Î†âÏÖòÏóêÏÑú ÏãúÎèÑ (fallback)
    const q = query(
      collection(db, "tasks"),
      where("projectId", "==", projectId)
    );
    const querySnapshot = await getDocs(q);

    let completedTime = 0;
    let remainingTime = 0;

    querySnapshot.docs.forEach((doc) => {
      const data = doc.data();
      const duration = data.duration || 0;
      if (data.done === true) {
        completedTime += duration;
      } else {
        remainingTime += duration;
      }
    });

    return { completedTime, remainingTime };
  }
};

export const fetchTaskById = async (taskId: string): Promise<Task> => {
  const docRef = doc(db, "tasks", taskId);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    const data = docSnap.data();
    return {
      id: docSnap.id,
      ...data,
      date: data.date.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Task;
  } else {
    throw new Error("Task not found");
  }
};

// Chapters
export const fetchAllChaptersByUserId = async (
  userId: string
): Promise<Chapter[]> => {
  const q = query(collection(db, "chapters"), where("userId", "==", userId));
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate.toDate(),
      endDate: data.endDate.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedProjects: data.connectedProjects || [],
    } as Chapter;
  });
};

export const fetchChapterById = async (chapterId: string): Promise<Chapter> => {
  const docRef = doc(db, "chapters", chapterId);
  const docSnap = await getDoc(docRef);

  if (docSnap.exists()) {
    const data = docSnap.data();
    return {
      id: docSnap.id,
      ...data,
      startDate: data.startDate.toDate(),
      endDate: data.endDate.toDate(),
      // status ÌïÑÎìú Ï†úÍ±∞ - ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú ÎÇ†Ïßú Í∏∞Î∞òÏúºÎ°ú Í≥ÑÏÇ∞
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      connectedProjects: data.connectedProjects || [],
    } as Chapter;
  } else {
    throw new Error("Chapter not found");
  }
};

// ÌäπÏ†ï ÏõîÏùò Í∏∞Ï°¥ Ï±ïÌÑ∞ Ï∞æÍ∏∞
export const findChapterByMonth = async (
  userId: string,
  year: number,
  month: number
): Promise<Chapter | null> => {
  const q = query(collection(db, "chapters"), where("userId", "==", userId));
  const querySnapshot = await getDocs(q);

  for (const doc of querySnapshot.docs) {
    const data = doc.data();
    const chapterStartDate = data.startDate.toDate();

    // Ï±ïÌÑ∞Ïùò ÏãúÏûë ÏõîÍ≥º ÎπÑÍµê
    if (
      chapterStartDate.getFullYear() === year &&
      chapterStartDate.getMonth() === month - 1
    ) {
      return {
        id: doc.id,
        userId: data.userId,
        title: data.title,
        startDate: data.startDate.toDate(),
        endDate: data.endDate.toDate(),
        focusAreas: data.focusAreas,
        // projectIdsÎäî Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå (connectedChaptersÎ°ú ÎåÄÏ≤¥)
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
        doneCount: data.doneCount,
        targetCount: data.targetCount,
        reward: data.reward,
        connectedProjects: data.connectedProjects || [],
      } as Chapter;
    }
  }

  return null;
};

// Ï±ïÌÑ∞Ïùò ÎØ∏ÏôÑÎ£å ÌîÑÎ°úÏ†ùÌä∏ Ï∞æÍ∏∞
export const findIncompleteProjectsInChapter = async (
  chapterId: string
): Promise<Project[]> => {
  const q = query(
    collection(db, "projects"),
    where("connectedChapters", "array-contains", chapterId)
  );
  const querySnapshot = await getDocs(q);

  const incompleteProjects: Project[] = [];

  for (const doc of querySnapshot.docs) {
    const data = doc.data();

    // ÌîÑÎ°úÏ†ùÌä∏Ïùò ÏôÑÎ£å ÏÉÅÌÉú ÌôïÏù∏ (tasks Í∏∞Î∞ò)
    const tasksQuery = query(
      collection(db, "tasks"),
      where("projectId", "==", doc.id)
    );
    const tasksSnapshot = await getDocs(tasksQuery);

    const tasks = tasksSnapshot.docs.map((taskDoc) => taskDoc.data());
    const totalTasks = tasks.length;
    const completedTasks = tasks.filter((task) => task.done).length;

    // ÏôÑÎ£åÎêòÏßÄ ÏïäÏùÄ ÌîÑÎ°úÏ†ùÌä∏Îßå Ï∂îÍ∞Ä
    if (totalTasks === 0 || completedTasks < totalTasks) {
      incompleteProjects.push({
        id: doc.id,
        userId: data.userId,
        title: data.title,
        description: data.description,
        category: data.category,
        area: data.area,
        areaId: data.areaId,
        target: data.target || totalTasks, // targetÏù¥ ÏóÜÏúºÎ©¥ totalTasks ÏÇ¨Ïö©
        completedTasks: completedTasks,
        startDate: data.startDate?.toDate(),
        endDate: data.endDate?.toDate(),
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
        chapterId: data.chapterId,
        connectedChapters: data.connectedChapters || [],
        addedMidway: data.addedMidway,
        retrospective: data.retrospective,
        notes: data.notes || [], // notes Î∞∞Ïó¥Ïù¥ ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥
        isCarriedOver: data.isCarriedOver,
        originalChapterId: data.originalChapterId,
        carriedOverAt: data.carriedOverAt?.toDate(),
        migrationStatus: data.migrationStatus,
        status: data.status || "in_progress", // statusÍ∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í
      } as Project);
    }
  }

  return incompleteProjects;
};

// ÌîÑÎ°úÏ†ùÌä∏Î•º Îã§Î•∏ Ï±ïÌÑ∞Î°ú Ïù¥Îèô
export const moveProjectToChapter = async (
  projectId: string,
  fromChapterId: string,
  toChapterId: string
): Promise<void> => {
  const projectRef = doc(db, "projects", projectId);
  const projectSnap = await getDoc(projectRef);

  if (!projectSnap.exists()) {
    throw new Error("Project not found");
  }

  const projectData = projectSnap.data();
  const connectedChapters = (projectData as any).connectedChapters || [];

  // Í∏∞Ï°¥ Ï±ïÌÑ∞ÏóêÏÑú Ï†úÍ±∞ÌïòÍ≥† ÏÉà Ï±ïÌÑ∞Ïóê Ï∂îÍ∞Ä
  const updatedConnectedChapters = connectedChapters
    .filter((chapterId: string) => chapterId !== fromChapterId)
    .concat([toChapterId]);

  // ÌîÑÎ°úÏ†ùÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
  await updateDoc(projectRef, {
    connectedChapters: updatedConnectedChapters,
    isCarriedOver: true,
    originalChapterId: fromChapterId,
    carriedOverAt: new Date(),
    migrationStatus: "migrated",
    updatedAt: new Date(),
  });
};

// Retrospectives
export const fetchAllRetrospectivesByUserId = async (
  userId: string
): Promise<Retrospective[]> => {
  const q = query(
    collection(db, "retrospectives"),
    where("userId", "==", userId)
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Retrospective;
  });
};

export const fetchRetrospectiveById = async (
  retrospectiveId: string
): Promise<Retrospective> => {
  const docRef = doc(db, "retrospectives", retrospectiveId);
  const docSnap = await getDoc(docRef);
  if (docSnap.exists()) {
    const data = docSnap.data();
    return {
      id: docSnap.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Retrospective;
  } else {
    throw new Error("Retrospective not found");
  }
};

export const fetchRetrospectivesByChapterId = async (
  chapterId: string
): Promise<Retrospective[]> => {
  const q = query(
    collection(db, "retrospectives"),
    where("chapterId", "==", chapterId)
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Retrospective;
  });
};

export const fetchRetrospectivesByProjectId = async (
  projectId: string
): Promise<Retrospective[]> => {
  const q = query(
    collection(db, "retrospectives"),
    where("projectId", "==", projectId)
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Retrospective;
  });
};

// Archive (Í∏∞Ï°¥ Ìï®Ïàò ÏóÖÎç∞Ïù¥Ìä∏)
export const fetchArchivedItemsByUserId = async (
  userId: string
): Promise<any> => {
  // TODO: implement fetchArchive - ÌòÑÏû¨Îäî Îπà Í∞ùÏ≤¥ Î∞òÌôò
  return {};
};

// --- Data Creation/Update Functions ---

// Areas
export const createArea = async (
  areaData: Omit<Area, "id" | "createdAt" | "updatedAt">
): Promise<Area> => {
  const baseData = createBaseData(areaData.userId);
  const newArea = {
    ...areaData,
    ...baseData,
  };

  const docRef = await addDoc(collection(db, "areas"), newArea);

  // Area ÌÉÄÏûÖÏóê ÎßûÎäî Í∞ùÏ≤¥Î°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
  return {
    id: docRef.id,
    userId: areaData.userId,
    name: areaData.name,
    description: areaData.description,
    icon: areaData.icon,
    color: areaData.color,
    status: areaData.status || "active",
    createdAt: new Date(),
    updatedAt: new Date(),
  } as Area;
};

// "ÎØ∏Î∂ÑÎ•ò" ÏòÅÏó≠ ÏÉùÏÑ± ÎòêÎäî Í∞ÄÏ†∏Ïò§Í∏∞
export const getOrCreateUncategorizedArea = async (
  userId: string
): Promise<Area> => {
  try {
    // Í∏∞Ï°¥ "ÎØ∏Î∂ÑÎ•ò" ÏòÅÏó≠Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    const areasRef = collection(db, "areas");
    const q = query(
      areasRef,
      where("userId", "==", userId),
      where("name", "==", "ÎØ∏Î∂ÑÎ•ò")
    );
    const querySnapshot = await getDocs(q);

    if (!querySnapshot.empty) {
      // Í∏∞Ï°¥ "ÎØ∏Î∂ÑÎ•ò" ÏòÅÏó≠ Î∞òÌôò
      const doc = querySnapshot.docs[0];
      const data = doc.data();
      return {
        id: doc.id,
        userId: data.userId,
        name: data.name,
        description: data.description,
        icon: data.icon,
        color: data.color,
        status: data.status,
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      } as Area;
    } else {
      // ÏÉàÎ°úÏö¥ "ÎØ∏Î∂ÑÎ•ò" ÏòÅÏó≠ ÏÉùÏÑ±
      const uncategorizedArea = {
        name: "ÎØ∏Î∂ÑÎ•ò",
        description: "ÏïÑÏßÅ Î∂ÑÎ•òÎêòÏßÄ ÏïäÏùÄ Ìï≠Î™©Îì§ÏùÑ ÏúÑÌïú ÏòÅÏó≠ÏûÖÎãàÎã§",
        color: "#6B7280", // ÌöåÏÉâ
        status: "active" as const,
        userId,
      };
      return await createArea(uncategorizedArea);
    }
  } catch (error) {
    console.error("ÎØ∏Î∂ÑÎ•ò ÏòÅÏó≠ ÏÉùÏÑ±/Ï°∞Ìöå Ïã§Ìå®:", error);
    throw new Error("ÎØ∏Î∂ÑÎ•ò ÏòÅÏó≠ÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.");
  }
};

export const updateArea = async (
  areaId: string,
  updateData: Partial<Omit<Area, "id" | "userId" | "createdAt">>
): Promise<void> => {
  // ÏòÅÏó≠ Ï†ïÎ≥¥ Î®ºÏ†Ä Í∞ÄÏ†∏Ïò§Í∏∞
  const area = await fetchAreaById(areaId);

  // "ÎØ∏Î∂ÑÎ•ò" ÏòÅÏó≠ÏùÄ ÏàòÏ†ïÌï† Ïàò ÏóÜÏùå
  if (area.name === "ÎØ∏Î∂ÑÎ•ò") {
    throw new Error("ÎØ∏Î∂ÑÎ•ò ÏòÅÏó≠ÏùÄ ÏàòÏ†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
  }

  const docRef = doc(db, "areas", areaId);
  await updateDoc(docRef, {
    ...updateData,
    updatedAt: updateTimestamp(),
  });
};

// Resources
export const createResource = async (
  resourceData: Omit<Resource, "id" | "createdAt" | "updatedAt">
): Promise<Resource> => {
  const baseData = createBaseData(resourceData.userId);
  const newResource = {
    ...resourceData,
    ...baseData,
  };

  const docRef = await addDoc(collection(db, "resources"), newResource);

  // Resource ÌÉÄÏûÖÏóê ÎßûÎäî Í∞ùÏ≤¥Î°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
  return {
    id: docRef.id,
    userId: resourceData.userId,
    name: resourceData.name,
    areaId: resourceData.areaId,
    area: resourceData.area,
    areaColor: resourceData.areaColor,
    description: resourceData.description,
    text: resourceData.text,
    link: resourceData.link,
    createdAt: new Date(),
    updatedAt: new Date(),
  } as Resource;
};

export const updateResource = async (
  resourceId: string,
  updateData: Partial<Omit<Resource, "id" | "userId" | "createdAt">>
): Promise<void> => {
  const docRef = doc(db, "resources", resourceId);
  await updateDoc(docRef, {
    ...updateData,
    updatedAt: updateTimestamp(),
  });
};

// Projects
export const createProject = async (
  projectData: Omit<Project, "id" | "createdAt" | "updatedAt">
): Promise<Project> => {
  const baseData = createBaseData(projectData.userId);

  // Date Í∞ùÏ≤¥Ïùò Ïú†Ìö®ÏÑ±ÏùÑ Í≤ÄÏÇ¨ÌïòÍ≥† ÏïàÏ†ÑÌïòÍ≤å TimestampÎ°ú Î≥ÄÌôò
  const safeDateToTimestamp = (date: Date | any) => {
    if (!date) return Timestamp.now();

    // Date Í∞ùÏ≤¥Ïù∏ÏßÄ ÌôïÏù∏
    if (date instanceof Date) {
      // Ïú†Ìö®Ìïú DateÏù∏ÏßÄ ÌôïÏù∏
      if (isNaN(date.getTime())) {
        console.warn("Invalid Date detected, using current timestamp");
        return Timestamp.now();
      }
      return Timestamp.fromDate(date);
    }

    // Î¨∏ÏûêÏó¥Ïù∏ Í≤ΩÏö∞ DateÎ°ú Î≥ÄÌôò ÏãúÎèÑ
    if (typeof date === "string") {
      const parsedDate = new Date(date);
      if (isNaN(parsedDate.getTime())) {
        console.warn("Invalid date string detected, using current timestamp");
        return Timestamp.now();
      }
      return Timestamp.fromDate(parsedDate);
    }

    // Í∑∏ Ïô∏Ïùò Í≤ΩÏö∞ ÌòÑÏû¨ ÏãúÍ∞Ñ ÏÇ¨Ïö©
    console.warn("Unknown date format, using current timestamp");
    return Timestamp.now();
  };

  const newProject = {
    ...projectData,
    ...baseData,
    startDate: safeDateToTimestamp(projectData.startDate),
    endDate: safeDateToTimestamp(projectData.endDate),
  };

  console.log("üî• Firestore: Creating project with data:", {
    title: newProject.title,
    startDate: newProject.startDate,
    endDate: newProject.endDate,
    target: newProject.target,
  });

  const docRef = await addDoc(collection(db, "projects"), newProject);

  // Project ÌÉÄÏûÖÏóê ÎßûÎäî Í∞ùÏ≤¥Î°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
  return {
    id: docRef.id,
    userId: projectData.userId,
    title: projectData.title,
    description: projectData.description,
    category: projectData.category,
    areaId: projectData.areaId,
    area: projectData.area,
    target: projectData.target,
    targetCount: projectData.targetCount,
    completedTasks: projectData.completedTasks || 0,
    startDate: projectData.startDate,
    endDate: projectData.endDate,
    createdAt: new Date(),
    updatedAt: new Date(),
    chapterId: projectData.chapterId,
    connectedChapters: projectData.connectedChapters || [],

    addedMidway: projectData.addedMidway,
    retrospective: projectData.retrospective,
    notes: projectData.notes || [],
    isCarriedOver: projectData.isCarriedOver,
    originalChapterId: projectData.originalChapterId,
    carriedOverAt: projectData.carriedOverAt,
    migrationStatus: projectData.migrationStatus,
  } as Project;
};

export const updateProject = async (
  projectId: string,
  updateData: Partial<Omit<Project, "id" | "userId" | "createdAt">>
): Promise<void> => {
  // Date Í∞ùÏ≤¥Î•º TimestampÎ°ú Î≥ÄÌôò
  const convertedUpdateData = {
    ...updateData,
    updatedAt: updateTimestamp(),
  };

  // startDateÏôÄ endDateÍ∞Ä Date Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞ TimestampÎ°ú Î≥ÄÌôò
  if (updateData.startDate) {
    convertedUpdateData.startDate = Timestamp.fromDate(
      updateData.startDate
    ) as any;
  }
  if (updateData.endDate) {
    convertedUpdateData.endDate = Timestamp.fromDate(updateData.endDate) as any;
  }

  const docRef = doc(db, "projects", projectId);
  await updateDoc(docRef, convertedUpdateData);
};

// Tasks
export const createTask = async (
  taskData: Omit<Task, "id" | "createdAt" | "updatedAt">
): Promise<Task> => {
  const baseData = createBaseData(taskData.userId);

  // Date Í∞ùÏ≤¥Î•º TimestampÎ°ú Î≥ÄÌôò
  const newTask = {
    ...taskData,
    ...baseData,
    date:
      taskData.date instanceof Date
        ? Timestamp.fromDate(taskData.date)
        : taskData.date,
  };

  const docRef = await addDoc(collection(db, "tasks"), newTask);

  // Task ÌÉÄÏûÖÏóê ÎßûÎäî Í∞ùÏ≤¥Î°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
  return {
    id: docRef.id,
    userId: taskData.userId,
    projectId: taskData.projectId,
    title: taskData.title,
    date: taskData.date,
    duration: taskData.duration,
    done: taskData.done,
    createdAt: new Date(),
    updatedAt: new Date(),
  } as Task;
};

export const updateTask = async (
  taskId: string,
  updateData: Partial<Omit<Task, "id" | "userId" | "createdAt">>
): Promise<void> => {
  const docRef = doc(db, "tasks", taskId);
  await updateDoc(docRef, {
    ...updateData,
    updatedAt: updateTimestamp(),
  });
};

// ÌîÑÎ°úÏ†ùÌä∏Ïóê ÌÉúÏä§ÌÅ¨ Ï∂îÍ∞Ä
export const addTaskToProject = async (
  projectId: string,
  taskData: Omit<
    Task,
    "id" | "projectId" | "userId" | "createdAt" | "updatedAt"
  >
): Promise<Task> => {
  // Î®ºÏ†Ä ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏ÏôÄÏÑú userId ÌôïÏù∏
  const projectDoc = await getDoc(doc(db, "projects", projectId));
  if (!projectDoc.exists()) {
    throw new Error("Project not found");
  }

  const projectData = projectDoc.data();
  const newTask = {
    ...taskData,
    projectId,
    userId: projectData.userId,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const docRef = await addDoc(collection(db, "tasks"), newTask);
  return { id: docRef.id, ...newTask } as Task;
};

// ÌîÑÎ°úÏ†ùÌä∏ ÌÉúÏä§ÌÅ¨ ÏàòÏ†ï
export const updateTaskInProject = async (
  taskId: string,
  updateData: Partial<Omit<Task, "id" | "projectId" | "userId" | "createdAt">>
): Promise<void> => {
  const docRef = doc(db, "tasks", taskId);
  await updateDoc(docRef, {
    ...updateData,
    updatedAt: new Date(),
  });
};

// ÌîÑÎ°úÏ†ùÌä∏ ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú
export const deleteTaskFromProject = async (taskId: string): Promise<void> => {
  try {
    console.log(`üóëÔ∏è Firestore: ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú ÏãúÏûë - ID: ${taskId}`);
    const docRef = doc(db, "tasks", taskId);
    await deleteDoc(docRef);
    console.log(`‚úÖ Firestore: ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú ÏôÑÎ£å - ID: ${taskId}`);
  } catch (error) {
    console.error(`‚ùå Firestore: ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú Ïã§Ìå® - ID: ${taskId}`, error);
    throw new Error("ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// Chapters
export const createChapter = async (
  chapterData: Omit<Chapter, "id" | "createdAt" | "updatedAt">
): Promise<Chapter> => {
  const baseData = createBaseData(chapterData.userId);

  // Date Í∞ùÏ≤¥Î•º TimestampÎ°ú Î≥ÄÌôò
  const newChapter = {
    ...chapterData,
    ...baseData,
    startDate:
      chapterData.startDate instanceof Date
        ? Timestamp.fromDate(chapterData.startDate)
        : chapterData.startDate,
    endDate:
      chapterData.endDate instanceof Date
        ? Timestamp.fromDate(chapterData.endDate)
        : chapterData.endDate,
  };

  const docRef = await addDoc(collection(db, "chapters"), newChapter);

  // Chapter ÌÉÄÏûÖÏóê ÎßûÎäî Í∞ùÏ≤¥Î°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
  return {
    id: docRef.id,
    userId: chapterData.userId,
    title: chapterData.title,
    startDate: chapterData.startDate,
    endDate: chapterData.endDate,
    status: chapterData.status || "planned",
    retrospective: chapterData.retrospective,
    focusAreas: chapterData.focusAreas || [],
    connectedProjects: chapterData.connectedProjects || [],
    createdAt: new Date(),
    updatedAt: new Date(),
  } as Chapter;
};

export const updateChapter = async (
  chapterId: string,
  updateData: Partial<Omit<Chapter, "id" | "userId" | "createdAt">>
): Promise<void> => {
  const docRef = doc(db, "chapters", chapterId);
  await updateDoc(docRef, {
    ...updateData,
    updatedAt: updateTimestamp(),
  });
};

// Retrospectives
export const createRetrospective = async (
  retrospectiveData: Omit<Retrospective, "id" | "createdAt" | "updatedAt">
): Promise<Retrospective> => {
  const baseData = createBaseData(retrospectiveData.userId);
  const newRetrospective = {
    ...retrospectiveData,
    ...baseData,
  };

  const docRef = await addDoc(
    collection(db, "retrospectives"),
    newRetrospective
  );

  // Retrospective ÌÉÄÏûÖÏóê ÎßûÎäî Í∞ùÏ≤¥Î°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
  return {
    id: docRef.id,
    userId: retrospectiveData.userId,
    title: retrospectiveData.title,
    projectId: retrospectiveData.projectId,
    chapterId: retrospectiveData.chapterId,
    content: retrospectiveData.content,
    bestMoment: retrospectiveData.bestMoment,
    routineAdherence: retrospectiveData.routineAdherence,
    userRating: retrospectiveData.userRating,
    createdAt: new Date(),
    updatedAt: new Date(),
  } as Retrospective;
};

export const updateRetrospective = async (
  retrospectiveId: string,
  updateData: Partial<Omit<Retrospective, "id" | "userId" | "createdAt">>
): Promise<void> => {
  const docRef = doc(db, "retrospectives", retrospectiveId);
  await updateDoc(docRef, {
    ...updateData,
    updatedAt: updateTimestamp(),
  });
};

// Notes
export const createNote = async (
  noteData: Omit<Note, "id" | "createdAt" | "updatedAt">
): Promise<Note> => {
  const baseData = createBaseData(noteData.userId);
  const newNote = {
    ...noteData,
    ...baseData,
  };

  const docRef = await addDoc(collection(db, "notes"), newNote);

  // Note ÌÉÄÏûÖÏóê ÎßûÎäî Í∞ùÏ≤¥Î°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
  return {
    id: docRef.id,
    userId: noteData.userId,
    content: noteData.content,
    createdAt: new Date(),
    updatedAt: new Date(),
  } as Note;
};

export const updateNote = async (
  noteId: string,
  updateData: Partial<Omit<Note, "id" | "userId" | "createdAt">>
): Promise<void> => {
  const docRef = doc(db, "notes", noteId);
  await updateDoc(docRef, {
    ...updateData,
    updatedAt: updateTimestamp(),
  });
};

// --- User Functions ---

export const fetchUserById = async (userId: string): Promise<User> => {
  const docRef = doc(db, "users", userId);
  const docSnap = await getDoc(docRef);

  if (docSnap.exists()) {
    const data = docSnap.data();
    return {
      id: docSnap.id,
      profile: {
        ...data.profile,
        createdAt: data.profile.createdAt.toDate(),
        updatedAt: data.profile.updatedAt.toDate(),
      },
      settings: data.settings,
      preferences: data.preferences,
    } as User;
  } else {
    throw new Error("User not found");
  }
};

export const createUser = async (
  userId: string,
  userData: {
    profile: Omit<UserProfile, "createdAt" | "updatedAt">;
    settings?: Partial<UserSettings>;
    preferences?: Partial<UserPreferences>;
  }
): Promise<User> => {
  const defaultSettings: UserSettings = {
    defaultReward: "",
    defaultRewardEnabled: false,
    carryOver: true, // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú trueÎ°ú ÏÑ§Ï†ï
    aiRecommendations: true,
    notifications: true,
    theme: "system",
    language: "ko",
  };

  const defaultPreferences: UserPreferences = {
    timezone: "Asia/Seoul",
    dateFormat: "ko-KR",
    weeklyStartDay: "monday",
  };

  const userDoc = {
    profile: {
      ...userData.profile,
      createdAt: createTimestamp(),
      updatedAt: createTimestamp(),
    },
    settings: {
      ...defaultSettings,
      ...userData.settings,
    },
    preferences: {
      ...defaultPreferences,
      ...userData.preferences,
    },
  };

  await setDoc(doc(db, "users", userId), userDoc);

  // User ÌÉÄÏûÖÏóê ÎßûÎäî Í∞ùÏ≤¥Î°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò
  return {
    id: userId,
    profile: {
      ...userData.profile,
      createdAt: new Date(),
      updatedAt: new Date(),
    },
    settings: {
      ...defaultSettings,
      ...userData.settings,
    },
    preferences: {
      ...defaultPreferences,
      ...userData.preferences,
    },
  } as User;
};

export const updateUserProfile = async (
  userId: string,
  updateData: Partial<Omit<UserProfile, "createdAt">>
): Promise<void> => {
  const docRef = doc(db, "users", userId);
  await updateDoc(docRef, {
    profile: {
      ...updateData,
      updatedAt: updateTimestamp(),
    },
  });
};

export const updateUserSettings = async (
  userId: string,
  updateData: Partial<UserSettings>
): Promise<void> => {
  const docRef = doc(db, "users", userId);

  // Ï†ê ÌëúÍ∏∞Î≤ïÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ï§ëÏ≤© ÌïÑÎìú ÏóÖÎç∞Ïù¥Ìä∏
  const updateFields: any = {};
  Object.entries(updateData).forEach(([key, value]) => {
    updateFields[`settings.${key}`] = value;
  });

  console.log("Updating user settings:", { userId, updateData, updateFields });

  try {
    await updateDoc(docRef, updateFields);
    console.log("User settings updated successfully");
  } catch (error) {
    console.error("Failed to update user settings:", error);
    throw error;
  }
};

export const updateUserPreferences = async (
  userId: string,
  updateData: Partial<UserPreferences>
): Promise<void> => {
  const docRef = doc(db, "users", userId);

  // Ï†ê ÌëúÍ∏∞Î≤ïÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ï§ëÏ≤© ÌïÑÎìú ÏóÖÎç∞Ïù¥Ìä∏
  const updateFields: any = {};
  Object.entries(updateData).forEach(([key, value]) => {
    updateFields[`preferences.${key}`] = value;
  });

  await updateDoc(docRef, updateFields);
};

// --- Firebase Auth Profile Update ---

export const updateUserDisplayName = async (
  displayName: string
): Promise<void> => {
  const currentUser = auth.currentUser;
  if (!currentUser) {
    throw new Error("Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©ÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§.");
  }

  await updateProfile(currentUser, {
    displayName: displayName,
  });
};

// ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏóÖÎ°úÎìú Ìï®Ïàò
export const uploadProfilePicture = async (
  file: File,
  userId: string
): Promise<string> => {
  try {
    // ÌååÏùº ÌôïÏû•Ïûê ÌôïÏù∏
    const allowedTypes = ["image/jpeg", "image/jpg", "image/png", "image/gif"];
    if (!allowedTypes.includes(file.type)) {
      throw new Error(
        "ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌååÏùº ÌòïÏãùÏûÖÎãàÎã§. JPEG, PNG, GIF ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§."
      );
    }

    // ÌååÏùº ÌÅ¨Í∏∞ ÌôïÏù∏ (2MB Ï†úÌïú)
    const maxSize = 2 * 1024 * 1024; // 2MB
    if (file.size > maxSize) {
      throw new Error(
        "ÌååÏùº ÌÅ¨Í∏∞Í∞Ä ÎÑàÎ¨¥ ÌÅΩÎãàÎã§. 2MB Ïù¥ÌïòÏùò ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§."
      );
    }

    // Storage Ï∞∏Ï°∞ ÏÉùÏÑ±
    const storageRef = ref(storage, `profile-pictures/${userId}/${file.name}`);

    // ÌååÏùº ÏóÖÎ°úÎìú
    const snapshot = await uploadBytes(storageRef, file);

    // Îã§Ïö¥Î°úÎìú URL Í∞ÄÏ†∏Ïò§Í∏∞
    const downloadURL = await getDownloadURL(snapshot.ref);

    return downloadURL;
  } catch (error) {
    console.error("ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏóÖÎ°úÎìú Ïã§Ìå®:", error);
    throw error;
  }
};

// ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏÇ≠Ï†ú Ìï®Ïàò
export const deleteProfilePicture = async (
  userId: string,
  fileName: string
): Promise<void> => {
  try {
    const storageRef = ref(storage, `profile-pictures/${userId}/${fileName}`);
    await deleteObject(storageRef);
  } catch (error) {
    console.error("ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏÇ≠Ï†ú Ïã§Ìå®:", error);
    throw error;
  }
};

// ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ ÏÇ¨ÏßÑ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
export const updateUserProfilePicture = async (
  photoURL: string
): Promise<void> => {
  const user = auth.currentUser;
  if (!user) {
    throw new Error("ÏÇ¨Ïö©ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.");
  }

  await updateProfile(user, {
    photoURL,
  });
};

// Delete functions
export const deleteAreaById = async (
  areaId: string,
  deleteWithItems: boolean = false
): Promise<void> => {
  try {
    // ÏòÅÏó≠ Ï†ïÎ≥¥ Î®ºÏ†Ä Í∞ÄÏ†∏Ïò§Í∏∞
    const area = await fetchAreaById(areaId);

    // "ÎØ∏Î∂ÑÎ•ò" ÏòÅÏó≠ÏùÄ ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏùå
    if (area.name === "ÎØ∏Î∂ÑÎ•ò") {
      throw new Error("ÎØ∏Î∂ÑÎ•ò ÏòÅÏó≠ÏùÄ ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
    }

    if (deleteWithItems) {
      // Ïó∞Í≤∞Îêú ÌîÑÎ°úÏ†ùÌä∏Îì§ ÏÇ≠Ï†ú
      const projects = await fetchProjectsByAreaId(areaId);
      for (const project of projects) {
        await deleteProjectById(project.id);
      }

      // Ïó∞Í≤∞Îêú Î¶¨ÏÜåÏä§Îì§ ÏÇ≠Ï†ú
      const allResources = await fetchAllResourcesByUserId(area.userId);
      const areaResources = allResources.filter(
        (resource) => resource.areaId === areaId
      );

      for (const resource of areaResources) {
        await deleteResourceById(resource.id);
      }
    } else {
      // "ÎØ∏Î∂ÑÎ•ò" ÏòÅÏó≠ Í∞ÄÏ†∏Ïò§Í∏∞ ÎòêÎäî ÏÉùÏÑ±
      const uncategorizedArea = await getOrCreateUncategorizedArea(area.userId);

      // Ïó∞Í≤∞Îêú ÌîÑÎ°úÏ†ùÌä∏Îì§ÏùÑ "ÎØ∏Î∂ÑÎ•ò"Î°ú Ïù¥Îèô
      const projects = await fetchProjectsByAreaId(areaId);
      for (const project of projects) {
        await updateProject(project.id, { areaId: uncategorizedArea.id });
      }

      // Ïó∞Í≤∞Îêú Î¶¨ÏÜåÏä§Îì§ÏùÑ "ÎØ∏Î∂ÑÎ•ò"Î°ú Ïù¥Îèô
      const allResources = await fetchAllResourcesByUserId(area.userId);
      const areaResources = allResources.filter(
        (resource) => resource.areaId === areaId
      );

      for (const resource of areaResources) {
        await updateResource(resource.id, { areaId: uncategorizedArea.id });
      }
    }

    // Area ÏûêÏ≤¥ ÏÇ≠Ï†ú
    const docRef = doc(db, "areas", areaId);
    await deleteDoc(docRef);
  } catch (error) {
    console.error("Error deleting area:", error);
    throw new Error("ÏòÅÏó≠ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

export const deleteResourceById = async (resourceId: string): Promise<void> => {
  try {
    const docRef = doc(db, "resources", resourceId);
    await deleteDoc(docRef);
  } catch (error) {
    console.error("Error deleting resource:", error);
    throw new Error("ÏûêÎ£å ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

export const deleteProjectById = async (projectId: string): Promise<void> => {
  try {
    console.log(`üóëÔ∏è ÌîÑÎ°úÏ†ùÌä∏ ÏÇ≠Ï†ú ÏãúÏûë - ID: ${projectId}`);

    // 1. ÌîÑÎ°úÏ†ùÌä∏Ïóê Ïó∞Í¥ÄÎêú Î™®Îì† ÌÉúÏä§ÌÅ¨ Ï°∞Ìöå
    const tasks = await fetchAllTasksByProjectId(projectId);
    console.log(`üìã Î∞úÍ≤¨Îêú ÌÉúÏä§ÌÅ¨ Ïàò: ${tasks.length}Í∞ú`);

    // 2. Ïó∞Í¥ÄÎêú ÌÉúÏä§ÌÅ¨Îì§ ÏÇ≠Ï†ú
    if (tasks.length > 0) {
      console.log("üóëÔ∏è Ïó∞Í¥ÄÎêú ÌÉúÏä§ÌÅ¨Îì§ ÏÇ≠Ï†ú ÏãúÏûë...");
      for (const task of tasks) {
        try {
          await deleteTaskFromProject(task.id);
          console.log(`‚úÖ ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú ÏôÑÎ£å: ${task.title}`);
        } catch (error) {
          console.error(`‚ùå ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú Ïã§Ìå®: ${task.title}`, error);
          // ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú Ïã§Ìå®Ìï¥ÎèÑ ÌîÑÎ°úÏ†ùÌä∏ ÏÇ≠Ï†úÎäî Í≥ÑÏÜç ÏßÑÌñâ
        }
      }
      console.log("‚úÖ Î™®Îì† Ïó∞Í¥Ä ÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú ÏôÑÎ£å");
    }

    // 3. ÌîÑÎ°úÏ†ùÌä∏ ÏûêÏ≤¥ ÏÇ≠Ï†ú
    const docRef = doc(db, "projects", projectId);
    await deleteDoc(docRef);
    console.log(`‚úÖ ÌîÑÎ°úÏ†ùÌä∏ ÏÇ≠Ï†ú ÏôÑÎ£å - ID: ${projectId}`);
  } catch (error) {
    console.error("Error deleting project:", error);
    throw new Error("ÌîÑÎ°úÏ†ùÌä∏ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

export const deleteChapterById = async (chapterId: string): Promise<void> => {
  try {
    const docRef = doc(db, "chapters", chapterId);
    await deleteDoc(docRef);
  } catch (error) {
    console.error("Error deleting chapter:", error);
    throw new Error("Ï±ïÌÑ∞ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// ÏûêÎèô Ïù¥Í¥ÄÏùÑ ÏúÑÌïú Ìï®Ïàò: ÏôÑÎ£åÎêú Ï±ïÌÑ∞Ïùò ÎØ∏ÏôÑÎ£å ÌîÑÎ°úÏ†ùÌä∏Î•º Îã§Ïùå Ï±ïÌÑ∞Î°ú Ïù¥Í¥Ä
export const autoMigrateIncompleteProjects = async (
  userId: string,
  completedChapterId: string
): Promise<void> => {
  // ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï ÌôïÏù∏
  const userData = await fetchUserById(userId);
  const carryOverEnabled = userData.settings?.carryOver ?? true; // Í∏∞Î≥∏Í∞í true

  if (!carryOverEnabled) {
    console.log(
      `Carry over is disabled for user ${userId}. Skipping migration.`
    );
    return;
  }

  // 1. ÎØ∏ÏôÑÎ£å ÌîÑÎ°úÏ†ùÌä∏ Ï∞æÍ∏∞
  const incompleteProjects = await findIncompleteProjectsInChapter(
    completedChapterId
  );

  if (incompleteProjects.length === 0) {
    console.log("No incomplete projects to migrate");
    return;
  }

  // 2. Îã§Ïùå Îã¨ Ï±ïÌÑ∞ Ï∞æÍ∏∞ (ÏßÑÌñâ Ï§ëÏù¥Í±∞ÎÇò ÏòàÏ†ïÎêú Ï±ïÌÑ∞)
  const allChapters = await fetchAllChaptersByUserId(userId);
  const { getChapterStatus } = await import("./utils");

  const sortedChapters = allChapters
    .filter((chapter) => {
      const status = getChapterStatus(chapter);
      return status === "in_progress" || status === "planned";
    })
    .sort(
      (a, b) =>
        new Date(a.startDate).getTime() - new Date(b.startDate).getTime()
    );

  const targetChapter = sortedChapters[0]; // Í∞ÄÏû• Îπ†Î•∏ ÎØ∏Îûò Ï±ïÌÑ∞

  if (!targetChapter) {
    // Îã§Ïùå Îã¨ Ï±ïÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ ÌîÑÎ°úÏ†ùÌä∏Ïóê Ïù¥Í¥Ä ÎåÄÍ∏∞ ÏÉÅÌÉúÎ°ú ÎßàÌÇπ
    for (const project of incompleteProjects) {
      const projectRef = doc(db, "projects", project.id);
      await updateDoc(projectRef, {
        migrationStatus: "pending",
        originalChapterId: completedChapterId,
        updatedAt: new Date(),
      });
    }
    console.log(
      `Marked ${incompleteProjects.length} projects as pending migration`
    );
    return;
  }

  // 3. ÎØ∏ÏôÑÎ£å ÌîÑÎ°úÏ†ùÌä∏Îì§ÏùÑ Îã§Ïùå Ï±ïÌÑ∞Î°ú Ïù¥Í¥Ä
  for (const project of incompleteProjects) {
    try {
      await moveProjectToChapter(
        project.id,
        completedChapterId,
        targetChapter.id
      );
      console.log(
        `Migrated project ${project.title} to chapter ${targetChapter.title}`
      );
    } catch (error) {
      console.error(`Failed to migrate project ${project.id}:`, error);
    }
  }
};

// Ïù¥Í¥Ä ÎåÄÍ∏∞ Ï§ëÏù∏ ÌîÑÎ°úÏ†ùÌä∏Îì§ÏùÑ ÏÉàÎ°ú ÏÉùÏÑ±Îêú Ï±ïÌÑ∞Ïóê ÏûêÎèô Ïó∞Í≤∞
export const connectPendingProjectsToNewChapter = async (
  userId: string,
  newChapterId: string
): Promise<void> => {
  // ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï ÌôïÏù∏
  const userData = await fetchUserById(userId);
  const carryOverEnabled = userData.settings?.carryOver ?? true; // Í∏∞Î≥∏Í∞í true

  if (!carryOverEnabled) {
    console.log(
      `Carry over is disabled for user ${userId}. Skipping pending project connection.`
    );
    return;
  }

  const projectsQuery = query(
    collection(db, "projects"),
    where("userId", "==", userId),
    where("migrationStatus", "==", "pending")
  );

  const querySnapshot = await getDocs(projectsQuery);
  const pendingProjects = querySnapshot.docs.map((doc) => {
    const data = doc.data();
    return {
      id: doc.id,
      ...data,
      startDate: data.startDate?.toDate(),
      endDate: data.endDate?.toDate(),
      createdAt: data.createdAt.toDate(),
      updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
    } as Project;
  });

  for (const project of pendingProjects) {
    try {
      // Í∏∞Ï°¥ connectedChaptersÏóê ÏÉà Ï±ïÌÑ∞ Ï∂îÍ∞Ä
      const connectedChapters = (project as any).connectedChapters || [];
      const updatedChapters = [...connectedChapters, newChapterId];

      const projectRef = doc(db, "projects", project.id);
      await updateDoc(projectRef, {
        connectedChapters: updatedChapters,
        migrationStatus: "migrated",
        carriedOverAt: new Date(),
        updatedAt: new Date(),
      });

      // ÏÉà Ï±ïÌÑ∞ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
      const chapterRef = doc(db, "chapters", newChapterId);
      const chapterSnap = await getDoc(chapterRef);
      if (chapterSnap.exists()) {
        const chapterData = chapterSnap.data();
        const newChapterInfo = {
          id: newChapterId,
          title: chapterData.title,
          startDate: chapterData.startDate.toDate(),
          endDate: chapterData.endDate.toDate(),
        };

        // ÏÉà Ï±ïÌÑ∞Í∞Ä Ïù¥ÎØ∏ Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏßÄ ÏïäÏúºÎ©¥ Ï∂îÍ∞Ä
        const isAlreadyConnected = updatedChapters.some(
          (chapter: any) => chapter.id === newChapterId
        );

        const finalConnectedChapters = isAlreadyConnected
          ? updatedChapters
          : [...updatedChapters, newChapterInfo];

        await updateDoc(projectRef, {
          connectedChapters: finalConnectedChapters,
          migrationStatus: "migrated",
          carriedOverAt: new Date(),
          updatedAt: new Date(),
        });
      }

      console.log(`Connected pending project ${project.title} to new chapter`);
    } catch (error) {
      console.error(`Failed to connect pending project ${project.id}:`, error);
    }
  }
};

// ÏÉÅÌÉúÎ≥Ñ ÌîÑÎ°úÏ†ùÌä∏ Ï°∞Ìöå Ìï®ÏàòÎì§ (ÎèôÏ†Å Í≥ÑÏÇ∞ Í∏∞Î∞ò)

// ÏßÑÌñâ Ï§ëÏù∏ ÌîÑÎ°úÏ†ùÌä∏Îì§ Í∞ÄÏ†∏Ïò§Í∏∞
export const fetchActiveProjects = async (
  userId: string
): Promise<Project[]> => {
  try {
    const today = new Date();

    // ÏûÑÏãú Ìï¥Í≤∞Ï±Ö: Î≥µÌï© Ïù∏Îç±Ïä§ ÏóÜÏù¥ Î™®Îì† ÌîÑÎ°úÏ†ùÌä∏Î•º Í∞ÄÏ†∏Ïò® ÌõÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú ÌïÑÌÑ∞ÎßÅ
    const q = query(collection(db, "projects"), where("userId", "==", userId));

    const querySnapshot = await getDocs(q);
    const allProjects = querySnapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        startDate: data.startDate?.toDate(),
        endDate: data.endDate?.toDate(),
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      } as Project;
    });

    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú ÌòÑÏû¨ ÏßÑÌñâ Ï§ëÏù∏ ÌîÑÎ°úÏ†ùÌä∏Îì§ ÌïÑÌÑ∞ÎßÅ (ÏãúÏûëÏùº <= Ïò§Îäò <= Ï¢ÖÎ£åÏùº)
    return allProjects.filter((project) => {
      const startDate = new Date(project.startDate);
      const endDate = new Date(project.endDate);
      return startDate <= today && endDate >= today;
    });
  } catch (error) {
    console.error("ÏßÑÌñâ Ï§ëÏù∏ ÌîÑÎ°úÏ†ùÌä∏ Ï°∞Ìöå Ï§ë Ïò§Î•ò:", error);
    return [];
  }
};

// ÏôÑÎ£åÎêú ÌîÑÎ°úÏ†ùÌä∏Îì§ Í∞ÄÏ†∏Ïò§Í∏∞
export const fetchCompletedProjects = async (
  userId: string
): Promise<Project[]> => {
  try {
    const today = new Date();

    // ÏôÑÎ£åÎêú ÌîÑÎ°úÏ†ùÌä∏Îì§ (Ï¢ÖÎ£åÏùº < Ïò§Îäò ÎòêÎäî ÏôÑÎ£åÏú® 100%)
    const q = query(
      collection(db, "projects"),
      where("userId", "==", userId),
      where("endDate", "<", today)
    );

    const querySnapshot = await getDocs(q);
    const projects = querySnapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        startDate: data.startDate?.toDate(),
        endDate: data.endDate?.toDate(),
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      } as Project;
    });

    // ÏôÑÎ£åÏú® 100%Ïù∏ ÌîÑÎ°úÏ†ùÌä∏Îì§ÎèÑ Ìè¨Ìï®
    return projects.filter((project) => {
      const completionRate =
        project.targetCount && project.completedTasks
          ? (project.completedTasks / project.targetCount) * 100
          : 0;
      return completionRate >= 100;
    });
  } catch (error) {
    console.error("ÏôÑÎ£åÎêú ÌîÑÎ°úÏ†ùÌä∏ Ï°∞Ìöå Ï§ë Ïò§Î•ò:", error);
    return [];
  }
};

// Ïò§Îäò ÎßàÍ∞êÏù∏ ÌîÑÎ°úÏ†ùÌä∏ Ï≤¥ÌÅ¨ Ìï®Ïàò - ÏûÑÏãú Ìï¥Í≤∞Ï±Ö
export const getTodayDeadlineProjects = async (
  userId: string
): Promise<Project[]> => {
  try {
    const today = new Date();
    const todayDateOnly = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate()
    );
    const tomorrowDateOnly = new Date(todayDateOnly);
    tomorrowDateOnly.setDate(tomorrowDateOnly.getDate() + 1);

    // ÏûÑÏãú Ìï¥Í≤∞Ï±Ö: Î≥µÌï© Ïù∏Îç±Ïä§ ÏóÜÏù¥ Î™®Îì† ÌîÑÎ°úÏ†ùÌä∏Î•º Í∞ÄÏ†∏Ïò® ÌõÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú ÌïÑÌÑ∞ÎßÅ
    const q = query(collection(db, "projects"), where("userId", "==", userId));

    const querySnapshot = await getDocs(q);
    const allProjects = querySnapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        startDate: data.startDate?.toDate(),
        endDate: data.endDate?.toDate(),
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      } as Project;
    });

    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú Ïò§Îäò ÎßàÍ∞êÏù∏ ÌîÑÎ°úÏ†ùÌä∏Îì§ ÌïÑÌÑ∞ÎßÅ
    return allProjects.filter((project) => {
      const endDate = new Date(project.endDate);
      const projectEndDateOnly = new Date(
        endDate.getFullYear(),
        endDate.getMonth(),
        endDate.getDate()
      );
      return (
        projectEndDateOnly >= todayDateOnly &&
        projectEndDateOnly < tomorrowDateOnly
      );
    });
  } catch (error) {
    console.error("Ïò§Îäò ÎßàÍ∞ê ÌîÑÎ°úÏ†ùÌä∏ Ï°∞Ìöå Ï§ë Ïò§Î•ò:", error);
    return [];
  }
};

// Ïó∞Í∞Ñ ÌôúÎèô ÌÜµÍ≥Ñ Í∞ÄÏ†∏Ïò§Í∏∞
export const fetchYearlyActivityStats = async (
  userId: string,
  year: number
): Promise<any> => {
  try {
    // 1. ÏôÑÎ£åÎêú Ï±ïÌÑ∞Îì§ Í∞ÄÏ†∏Ïò§Í∏∞
    const allChapters = await fetchAllChaptersByUserId(userId);
    const completedChapters = allChapters.filter((chapter) => {
      const chapterYear = new Date(chapter.endDate).getFullYear();
      return chapterYear === year && getChapterStatus(chapter) === "ended";
    });

    // 2. Î∞õÏùÄ Î≥¥ÏÉÅ Ïàò Í≥ÑÏÇ∞
    const totalRewards = completedChapters.reduce(
      (sum, chapter) => sum + (chapter.reward ? 1 : 0),
      0
    );

    // 3. AreaÎ≥Ñ ÌôúÎèô ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
    const areas = await fetchAllAreasByUserId(userId);
    const areaStats: any = {};

    for (const area of areas) {
      const areaProjects = await fetchProjectsByAreaId(area.id);
      const yearProjects = areaProjects.filter((project) => {
        const projectYear = new Date(project.endDate).getFullYear();
        return projectYear === year;
      });

      const totalFocusTime = yearProjects.reduce(
        (sum, project) => sum + (project.targetCount || 0),
        0
      );

      const completedProjects = yearProjects.filter((project) => {
        const completionRate =
          project.targetCount && project.completedTasks
            ? (project.completedTasks / project.targetCount) * 100
            : 0;
        return completionRate >= 100;
      });

      const completionRate =
        yearProjects.length > 0
          ? Math.round((completedProjects.length / yearProjects.length) * 100)
          : 0;

      areaStats[area.id] = {
        name: area.name,
        focusTime: totalFocusTime,
        completionRate,
        projectCount: yearProjects.length,
      };
    }

    // 4. ÏõîÎ≥Ñ ÏßÑÌñâÎ•† Í≥ÑÏÇ∞
    const monthlyProgress: any = {};
    for (let month = 1; month <= 12; month++) {
      const monthChapters = completedChapters.filter((chapter) => {
        const chapterMonth = new Date(chapter.endDate).getMonth() + 1;
        return chapterMonth === month;
      });

      const totalFocusTime = monthChapters.reduce(
        (sum, chapter) => sum + (chapter.targetCount || 0),
        0
      );

      const completionRate =
        monthChapters.length > 0
          ? Math.round(
              (monthChapters.filter(
                (chapter) =>
                  (chapter.targetCount || 0) > 0 &&
                  chapter.doneCount >= (chapter.targetCount || 0)
              ).length /
                monthChapters.length) *
                100
            )
          : 0;

      monthlyProgress[month] = {
        completionRate,
        focusTime: totalFocusTime,
        projectCount: monthChapters.length,
      };
    }

    // 5. Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
    const totalFocusTime = completedChapters.reduce(
      (sum, chapter) => sum + (chapter.targetCount || 0),
      0
    );

    const averageCompletionRate =
      completedChapters.length > 0
        ? Math.round(
            completedChapters.reduce(
              (sum, chapter) =>
                sum +
                ((chapter.targetCount || 0) > 0
                  ? Math.round(
                      (chapter.doneCount / (chapter.targetCount || 0)) * 100
                    )
                  : 0),
              0
            ) / completedChapters.length
          )
        : 0;

    return {
      completedChapters: completedChapters.length,
      totalRewards,
      areaStats,
      monthlyProgress,
      totalFocusTime,
      averageCompletionRate,
    };
  } catch (error) {
    console.error("Ïó∞Í∞Ñ ÌôúÎèô ÌÜµÍ≥Ñ Ï°∞Ìöå Ï§ë Ïò§Î•ò:", error);
    return {
      completedChapters: 0,
      totalRewards: 0,
      areaStats: {},
      monthlyProgress: {},
      totalFocusTime: 0,
      averageCompletionRate: 0,
    };
  }
};

// Î™®Îì† ÌÉúÏä§ÌÅ¨Ïùò ÎÇ†ÏßúÎ•º Ìï¥Îãπ ÌîÑÎ°úÏ†ùÌä∏Ïùò ÏãúÏûëÏùºÎ°ú ÏàòÏ†ïÌïòÎäî Ìï®Ïàò
export const updateAllTasksToProjectStartDate = async (
  userId: string
): Promise<{ updatedTasks: number; totalTasks: number }> => {
  try {
    console.log("üîÑ Î™®Îì† ÌÉúÏä§ÌÅ¨ ÎÇ†ÏßúÎ•º ÌîÑÎ°úÏ†ùÌä∏ ÏãúÏûëÏùºÎ°ú ÏàòÏ†ï ÏãúÏûë");

    // 1. ÏÇ¨Ïö©ÏûêÏùò Î™®Îì† ÌîÑÎ°úÏ†ùÌä∏ Í∞ÄÏ†∏Ïò§Í∏∞
    const projects = await fetchAllProjectsByUserId(userId);
    console.log(`üìã Ï¥ù ${projects.length}Í∞úÏùò ÌîÑÎ°úÏ†ùÌä∏ Î∞úÍ≤¨`);

    // 2. ÏÇ¨Ïö©ÏûêÏùò Î™®Îì† ÌÉúÏä§ÌÅ¨ Í∞ÄÏ†∏Ïò§Í∏∞
    const allTasks = await fetchAllTasksByUserId(userId);
    console.log(`üìù Ï¥ù ${allTasks.length}Í∞úÏùò ÌÉúÏä§ÌÅ¨ Î∞úÍ≤¨`);

    let updatedTasks = 0;
    const batch = writeBatch(db);

    // 3. Í∞Å ÌÉúÏä§ÌÅ¨Ïóê ÎåÄÌï¥ Ìï¥Îãπ ÌîÑÎ°úÏ†ùÌä∏Ïùò ÏãúÏûëÏùºÎ°ú ÎÇ†Ïßú ÏàòÏ†ï
    for (const task of allTasks) {
      const project = projects.find((p) => p.id === task.projectId);

      if (project) {
        const projectStartDate = new Date(project.startDate);
        const currentTaskDate = new Date(task.date);

        // ÌÉúÏä§ÌÅ¨ ÎÇ†ÏßúÍ∞Ä ÌîÑÎ°úÏ†ùÌä∏ ÏãúÏûëÏùºÍ≥º Îã§Î•∏ Í≤ΩÏö∞ÏóêÎßå ÏóÖÎç∞Ïù¥Ìä∏
        if (currentTaskDate.getTime() !== projectStartDate.getTime()) {
          const taskRef = doc(db, "tasks", task.id);
          batch.update(taskRef, {
            date: Timestamp.fromDate(projectStartDate),
            updatedAt: updateTimestamp(),
          });
          updatedTasks++;
          console.log(
            `‚úÖ ÌÉúÏä§ÌÅ¨ "${task.title}" ÎÇ†ÏßúÎ•º ÌîÑÎ°úÏ†ùÌä∏ "${project.title}" ÏãúÏûëÏùºÎ°ú ÏàòÏ†ï`
          );
        }
      } else {
        console.warn(
          `‚ö†Ô∏è ÌÉúÏä§ÌÅ¨ "${task.title}"Ïùò ÌîÑÎ°úÏ†ùÌä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå (projectId: ${task.projectId})`
        );
      }
    }

    // 4. Î∞∞Ïπò ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ
    if (updatedTasks > 0) {
      await batch.commit();
      console.log(
        `üéâ Ï¥ù ${updatedTasks}Í∞úÏùò ÌÉúÏä§ÌÅ¨ ÎÇ†ÏßúÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.`
      );
    } else {
      console.log("‚ÑπÔ∏è ÏàòÏ†ïÌï† ÌÉúÏä§ÌÅ¨Í∞Ä ÏóÜÏäµÎãàÎã§.");
    }

    return { updatedTasks, totalTasks: allTasks.length };
  } catch (error) {
    console.error("‚ùå ÌÉúÏä§ÌÅ¨ ÎÇ†Ïßú ÏàòÏ†ï Ï§ë Ïò§Î•ò Î∞úÏÉù:", error);
    throw new Error("ÌÉúÏä§ÌÅ¨ ÎÇ†Ïßú ÏàòÏ†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// ÌäπÏ†ï ÌîÑÎ°úÏ†ùÌä∏Ïùò Î™®Îì† ÌÉúÏä§ÌÅ¨ ÎÇ†ÏßúÎ•º ÌîÑÎ°úÏ†ùÌä∏ ÏãúÏûëÏùºÎ°ú ÏàòÏ†ïÌïòÎäî Ìï®Ïàò
export const updateProjectTasksToStartDate = async (
  projectId: string
): Promise<{ updatedTasks: number; totalTasks: number }> => {
  try {
    console.log(`üîÑ ÌîÑÎ°úÏ†ùÌä∏ ${projectId}Ïùò ÌÉúÏä§ÌÅ¨ ÎÇ†ÏßúÎ•º ÏãúÏûëÏùºÎ°ú ÏàòÏ†ï ÏãúÏûë`);

    // 1. ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const project = await fetchProjectById(projectId);
    console.log(`üìã ÌîÑÎ°úÏ†ùÌä∏ "${project.title}" Ï†ïÎ≥¥ Î°úÎìú`);

    // 2. ÌîÑÎ°úÏ†ùÌä∏Ïùò Î™®Îì† ÌÉúÏä§ÌÅ¨ Í∞ÄÏ†∏Ïò§Í∏∞
    const projectTasks = await fetchAllTasksByProjectId(projectId);
    console.log(`üìù ÌîÑÎ°úÏ†ùÌä∏Ïóê ${projectTasks.length}Í∞úÏùò ÌÉúÏä§ÌÅ¨ Î∞úÍ≤¨`);

    if (projectTasks.length === 0) {
      console.log("‚ÑπÔ∏è ÏàòÏ†ïÌï† ÌÉúÏä§ÌÅ¨Í∞Ä ÏóÜÏäµÎãàÎã§.");
      return { updatedTasks: 0, totalTasks: 0 };
    }

    let updatedTasks = 0;
    const batch = writeBatch(db);
    const projectStartDate = new Date(project.startDate);

    // 3. Í∞Å ÌÉúÏä§ÌÅ¨Ïùò ÎÇ†ÏßúÎ•º ÌîÑÎ°úÏ†ùÌä∏ ÏãúÏûëÏùºÎ°ú ÏàòÏ†ï
    for (const task of projectTasks) {
      const currentTaskDate = new Date(task.date);

      // ÌÉúÏä§ÌÅ¨ ÎÇ†ÏßúÍ∞Ä ÌîÑÎ°úÏ†ùÌä∏ ÏãúÏûëÏùºÍ≥º Îã§Î•∏ Í≤ΩÏö∞ÏóêÎßå ÏóÖÎç∞Ïù¥Ìä∏
      if (currentTaskDate.getTime() !== projectStartDate.getTime()) {
        const taskRef = doc(db, "tasks", task.id);
        batch.update(taskRef, {
          date: Timestamp.fromDate(projectStartDate),
          updatedAt: updateTimestamp(),
        });
        updatedTasks++;
        console.log(`‚úÖ ÌÉúÏä§ÌÅ¨ "${task.title}" ÎÇ†ÏßúÎ•º ÌîÑÎ°úÏ†ùÌä∏ ÏãúÏûëÏùºÎ°ú ÏàòÏ†ï`);
      }
    }

    // 4. Î∞∞Ïπò ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ
    if (updatedTasks > 0) {
      await batch.commit();
      console.log(
        `üéâ ÌîÑÎ°úÏ†ùÌä∏ "${project.title}"Ïùò ${updatedTasks}Í∞ú ÌÉúÏä§ÌÅ¨ ÎÇ†ÏßúÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.`
      );
    } else {
      console.log("‚ÑπÔ∏è ÏàòÏ†ïÌï† ÌÉúÏä§ÌÅ¨Í∞Ä ÏóÜÏäµÎãàÎã§.");
    }

    return { updatedTasks, totalTasks: projectTasks.length };
  } catch (error) {
    console.error("‚ùå ÌîÑÎ°úÏ†ùÌä∏ ÌÉúÏä§ÌÅ¨ ÎÇ†Ïßú ÏàòÏ†ï Ï§ë Ïò§Î•ò Î∞úÏÉù:", error);
    throw new Error("ÌîÑÎ°úÏ†ùÌä∏ ÌÉúÏä§ÌÅ¨ ÎÇ†Ïßú ÏàòÏ†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// ÌéòÏù¥ÏßïÏùÑ ÏúÑÌïú ÌîÑÎ°úÏ†ùÌä∏ Ï°∞Ìöå Ìï®Ïàò
export const fetchProjectsByUserIdWithPaging = async (
  userId: string,
  pageLimit: number = 10,
  lastDoc?: any,
  sortBy: string = "latest"
): Promise<{
  projects: Project[];
  lastDoc: any;
  hasMore: boolean;
}> => {
  try {
    let q = query(collection(db, "projects"), where("userId", "==", userId));

    // Ï†ïÎ†¨ Í∏∞Ï§ÄÏóê Îî∞Îùº ÏøºÎ¶¨ Íµ¨ÏÑ±
    switch (sortBy) {
      case "latest":
        q = query(q, orderBy("createdAt", "desc"));
        break;
      case "oldest":
        q = query(q, orderBy("createdAt", "asc"));
        break;
      case "name":
        q = query(q, orderBy("title", "asc"));
        break;
      default:
        q = query(q, orderBy("createdAt", "desc"));
    }

    // ÌéòÏù¥Ïßï Ï†ÅÏö©
    if (lastDoc) {
      q = query(q, startAfter(lastDoc));
    }
    q = query(q, limit(pageLimit + 1)); // Îã§Ïùå ÌéòÏù¥ÏßÄ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ÏùÑ ÏúÑÌï¥ +1

    const querySnapshot = await getDocs(q);
    const projects = querySnapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        startDate: data.startDate?.toDate(),
        endDate: data.endDate?.toDate(),
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      } as Project;
    });

    const hasMore = projects.length > pageLimit;
    const projectsToReturn = hasMore ? projects.slice(0, pageLimit) : projects;
    const newLastDoc = hasMore ? querySnapshot.docs[pageLimit - 1] : null;

    return {
      projects: projectsToReturn,
      lastDoc: newLastDoc,
      hasMore,
    };
  } catch (error) {
    console.error("Error fetching projects with paging:", error);
    throw new Error("ÌîÑÎ°úÏ†ùÌä∏ Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// ÌéòÏù¥ÏßïÏùÑ ÏúÑÌïú Î¶¨ÏÜåÏä§ Ï°∞Ìöå Ìï®Ïàò
export const fetchResourcesByUserIdWithPaging = async (
  userId: string,
  pageLimit: number = 10,
  lastDoc?: any,
  sortBy: string = "latest"
): Promise<{
  resources: Resource[];
  lastDoc: any;
  hasMore: boolean;
}> => {
  try {
    let q = query(collection(db, "resources"), where("userId", "==", userId));

    // Ï†ïÎ†¨ Í∏∞Ï§ÄÏóê Îî∞Îùº ÏøºÎ¶¨ Íµ¨ÏÑ±
    switch (sortBy) {
      case "latest":
        q = query(q, orderBy("createdAt", "desc"));
        break;
      case "oldest":
        q = query(q, orderBy("createdAt", "asc"));
        break;
      case "name":
        q = query(q, orderBy("name", "asc"));
        break;
      default:
        q = query(q, orderBy("createdAt", "desc"));
    }

    // ÌéòÏù¥Ïßï Ï†ÅÏö©
    if (lastDoc) {
      q = query(q, startAfter(lastDoc));
    }
    q = query(q, limit(pageLimit + 1)); // Îã§Ïùå ÌéòÏù¥ÏßÄ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ÏùÑ ÏúÑÌï¥ +1

    const querySnapshot = await getDocs(q);
    const resources = querySnapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      } as Resource;
    });

    const hasMore = resources.length > pageLimit;
    const resourcesToReturn = hasMore
      ? resources.slice(0, pageLimit)
      : resources;
    const newLastDoc = hasMore ? querySnapshot.docs[pageLimit - 1] : null;

    return {
      resources: resourcesToReturn,
      lastDoc: newLastDoc,
      hasMore,
    };
  } catch (error) {
    console.error("Error fetching resources with paging:", error);
    throw new Error("Î¶¨ÏÜåÏä§ Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// Î¶¨ÏÜåÏä§ÏôÄ Ïó∞Í≤∞Îêú ÏòÅÏó≠ Ï†ïÎ≥¥Î•º Ìï®Íªò Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
export const fetchResourcesWithAreasByUserIdWithPaging = async (
  userId: string,
  pageLimit: number = 10,
  lastDoc?: any,
  sortBy: string = "latest"
): Promise<{
  resources: Array<Resource & { area?: { id: string; name: string } }>;
  lastDoc: any;
  hasMore: boolean;
}> => {
  try {
    // Î®ºÏ†Ä Î¶¨ÏÜåÏä§Îì§ÏùÑ Í∞ÄÏ†∏Ïò¥
    const resourcesResult = await fetchResourcesByUserIdWithPaging(
      userId,
      pageLimit,
      lastDoc,
      sortBy
    );

    // Î¶¨ÏÜåÏä§Îì§Ïùò Í≥†Ïú†Ìïú areaIdÎì§ÏùÑ ÏàòÏßë
    const areaIds = [
      ...new Set(
        resourcesResult.resources
          .map((resource) => resource.areaId)
          .filter((areaId) => areaId) // null/undefined Ï†úÍ±∞
      ),
    ];

    // ÏòÅÏó≠ Ï†ïÎ≥¥Î•º Î∞∞ÏπòÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞
    const areasMap = new Map<string, { id: string; name: string }>();

    if (areaIds.length > 0) {
      const areasQuery = query(
        collection(db, "areas"),
        where("__name__", "in", areaIds)
      );
      const areasSnapshot = await getDocs(areasQuery);

      areasSnapshot.docs.forEach((doc) => {
        const data = doc.data();
        areasMap.set(doc.id, {
          id: doc.id,
          name: data.name || "Í∏∞ÌÉÄ",
        });
      });
    }

    // Î¶¨ÏÜåÏä§Ïóê ÏòÅÏó≠ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    const resourcesWithAreas = resourcesResult.resources.map((resource) => ({
      ...resource,
      area: resource.areaId ? areasMap.get(resource.areaId) : undefined,
    })) as Array<Resource & { area?: { id: string; name: string } }>;

    console.log(
      "PARA: Resources with areas:",
      resourcesWithAreas.map((r) => ({
        name: r.name,
        areaId: r.areaId,
        areaName: r.area?.name,
      }))
    );

    return {
      resources: resourcesWithAreas,
      lastDoc: resourcesResult.lastDoc,
      hasMore: resourcesResult.hasMore,
    };
  } catch (error) {
    console.error("Error fetching resources with areas:", error);
    throw new Error("Î¶¨ÏÜåÏä§ÏôÄ ÏòÅÏó≠ Ï†ïÎ≥¥ Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// ÏòÅÏó≠Î≥Ñ ÌîÑÎ°úÏ†ùÌä∏ÏôÄ Î¶¨ÏÜåÏä§ Í∞úÏàòÎßå Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò (ÏµúÏ†ÅÌôî)
export const fetchAreaCountsByUserId = async (
  userId: string
): Promise<{
  [areaId: string]: {
    projectCount: number;
    resourceCount: number;
  };
}> => {
  try {
    // Firestore ÏßëÍ≥Ñ ÏøºÎ¶¨Î°ú Í∞úÏàòÎßå Í≥ÑÏÇ∞
    const projectsQuery = query(
      collection(db, "projects"),
      where("userId", "==", userId)
    );
    const projectsSnapshot = await getDocs(projectsQuery);

    const resourcesQuery = query(
      collection(db, "resources"),
      where("userId", "==", userId)
    );
    const resourcesSnapshot = await getDocs(resourcesQuery);

    // ÏòÅÏó≠Î≥Ñ Í∞úÏàò Í≥ÑÏÇ∞ (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú ÏµúÏÜåÌïúÏùò Í≥ÑÏÇ∞)
    const stats: {
      [areaId: string]: { projectCount: number; resourceCount: number };
    } = {};

    // ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàò Í≥ÑÏÇ∞
    projectsSnapshot.docs.forEach((doc) => {
      const data = doc.data();
      const areaId = data.areaId;
      if (areaId) {
        if (!stats[areaId]) {
          stats[areaId] = { projectCount: 0, resourceCount: 0 };
        }
        stats[areaId].projectCount++;
      }
    });

    // Î¶¨ÏÜåÏä§ Í∞úÏàò Í≥ÑÏÇ∞
    resourcesSnapshot.docs.forEach((doc) => {
      const data = doc.data();
      const areaId = data.areaId;
      if (areaId) {
        if (!stats[areaId]) {
          stats[areaId] = { projectCount: 0, resourceCount: 0 };
        }
        stats[areaId].resourceCount++;
      }
    });

    return stats;
  } catch (error) {
    console.error("Error fetching area counts:", error);
    throw new Error("ÏòÅÏó≠Î≥Ñ Í∞úÏàò Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// ÌéòÏù¥ÏßïÏùÑ ÏúÑÌïú ÏïÑÏπ¥Ïù¥Î∏å Ï°∞Ìöå Ìï®Ïàò
export const fetchArchivesByUserIdWithPaging = async (
  userId: string,
  pageLimit: number = 10,
  lastDoc?: any,
  sortBy: string = "latest"
): Promise<{
  archives: Retrospective[];
  lastDoc: any;
  hasMore: boolean;
}> => {
  try {
    let q = query(
      collection(db, "retrospectives"),
      where("userId", "==", userId)
    );

    // Ï†ïÎ†¨ Í∏∞Ï§ÄÏóê Îî∞Îùº ÏøºÎ¶¨ Íµ¨ÏÑ±
    switch (sortBy) {
      case "latest":
        q = query(q, orderBy("createdAt", "desc"));
        break;
      case "oldest":
        q = query(q, orderBy("createdAt", "asc"));
        break;
      case "rating":
        q = query(q, orderBy("userRating", "desc"));
        break;
      default:
        q = query(q, orderBy("createdAt", "desc"));
    }

    // ÌéòÏù¥Ïßï Ï†ÅÏö©
    if (lastDoc) {
      q = query(q, startAfter(lastDoc));
    }
    q = query(q, limit(pageLimit + 1)); // Îã§Ïùå ÌéòÏù¥ÏßÄ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ÏùÑ ÏúÑÌï¥ +1

    const querySnapshot = await getDocs(q);
    const archives = querySnapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        createdAt: data.createdAt.toDate(),
        updatedAt: data.updatedAt?.toDate() || data.createdAt.toDate(),
      } as Retrospective;
    });

    const hasMore = archives.length > pageLimit;
    const archivesToReturn = hasMore ? archives.slice(0, pageLimit) : archives;
    const newLastDoc = hasMore ? querySnapshot.docs[pageLimit - 1] : null;

    return {
      archives: archivesToReturn,
      lastDoc: newLastDoc,
      hasMore,
    };
  } catch (error) {
    console.error("Error fetching archives with paging:", error);
    throw new Error("ÏïÑÏπ¥Ïù¥Î∏å Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàòÎßå Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
export const fetchProjectCountByUserId = async (
  userId: string
): Promise<number> => {
  try {
    const projectsQuery = query(
      collection(db, "projects"),
      where("userId", "==", userId)
    );
    const projectsSnapshot = await getDocs(projectsQuery);
    return projectsSnapshot.size;
  } catch (error) {
    console.error("Error fetching project count:", error);
    throw new Error("ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàò Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// Ï†ÑÏ≤¥ Î¶¨ÏÜåÏä§ Í∞úÏàòÎßå Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
export const fetchResourceCountByUserId = async (
  userId: string
): Promise<number> => {
  try {
    const resourcesQuery = query(
      collection(db, "resources"),
      where("userId", "==", userId)
    );
    const resourcesSnapshot = await getDocs(resourcesQuery);
    return resourcesSnapshot.size;
  } catch (error) {
    console.error("Error fetching resource count:", error);
    throw new Error("Î¶¨ÏÜåÏä§ Í∞úÏàò Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// Ï†ÑÏ≤¥ ÏïÑÏπ¥Ïù¥Î∏å Í∞úÏàòÎßå Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
export const fetchArchiveCountByUserId = async (
  userId: string
): Promise<number> => {
  try {
    const archivesQuery = query(
      collection(db, "retrospectives"),
      where("userId", "==", userId)
    );
    const archivesSnapshot = await getDocs(archivesQuery);
    return archivesSnapshot.size;
  } catch (error) {
    console.error("Error fetching archive count:", error);
    throw new Error("ÏïÑÏπ¥Ïù¥Î∏å Í∞úÏàò Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
  }
};

// Ï±ïÌÑ∞ÏôÄ ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàòÎ•º Ìïú Î≤àÏóê Ìö®Ïú®Ï†ÅÏúºÎ°ú Ï°∞ÌöåÌïòÎäî Ìï®Ïàò
export const fetchChaptersWithProjectCounts = async (
  userId: string
): Promise<(Chapter & { projectCount: number })[]> => {
  // 1. Î™®Îì† Ï±ïÌÑ∞ Ï°∞Ìöå
  const chapters = await fetchAllChaptersByUserId(userId);

  if (chapters.length === 0) return [];

  // 2. Î™®Îì† ÌîÑÎ°úÏ†ùÌä∏Î•º Ìïú Î≤àÏóê Ï°∞ÌöåÌïòÏó¨ Ï±ïÌÑ∞Î≥Ñ Í∞úÏàò Í≥ÑÏÇ∞
  const projectsQuery = query(
    collection(db, "projects"),
    where("userId", "==", userId)
  );
  const projectsSnapshot = await getDocs(projectsQuery);

  // 3. Ï±ïÌÑ∞Î≥Ñ ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàò Í≥ÑÏÇ∞
  const projectCounts: { [chapterId: string]: number } = {};

  console.log("üîç ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàò Í≥ÑÏÇ∞ ÏãúÏûë");
  console.log("Ï¥ù ÌîÑÎ°úÏ†ùÌä∏ Ïàò:", projectsSnapshot.size);

  projectsSnapshot.docs.forEach((doc) => {
    const projectData = doc.data();
    const connectedChapters = projectData.connectedChapters || [];

    console.log(
      `ÌîÑÎ°úÏ†ùÌä∏ "${projectData.title}"Ïùò connectedChapters:`,
      connectedChapters
    );

    // Ïù¥Ï†ú Îã®Ïàú ID Î∞∞Ïó¥Ïù¥ÎØÄÎ°ú ÏßÅÏ†ë ÏÇ¨Ïö©
    connectedChapters.forEach((chapterId: string) => {
      console.log("Ï±ïÌÑ∞ ID:", chapterId);
      if (chapterId) {
        projectCounts[chapterId] = (projectCounts[chapterId] || 0) + 1;
        console.log(
          `Ï±ïÌÑ∞ ${chapterId}Ïóê ÌîÑÎ°úÏ†ùÌä∏ Ï∂îÍ∞Ä. ÌòÑÏû¨ Í∞úÏàò: ${projectCounts[chapterId]}`
        );
      }
    });
  });

  console.log("ÏµúÏ¢Ö ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàò:", projectCounts);

  // 4. Ï±ïÌÑ∞Ïóê ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏàò Ï∂îÍ∞Ä
  return chapters.map((chapter) => ({
    ...chapter,
    projectCount: projectCounts[chapter.id] || 0,
  }));
};

// Ï±ïÌÑ∞ ID Î∞∞Ïó¥Î°ú Ï±ïÌÑ∞ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
export const fetchChaptersByIds = async (
  chapterIds: string[]
): Promise<Chapter[]> => {
  if (chapterIds.length === 0) return [];

  const connectedChapters: Chapter[] = [];

  // Î∞∞ÏπòÎ°ú Ï±ïÌÑ∞ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ (FirestoreÎäî 'in' ÏøºÎ¶¨ÏóêÏÑú ÏµúÎåÄ 10Í∞úÎßå ÏßÄÏõê)
  const batchSize = 10;
  for (let i = 0; i < chapterIds.length; i += batchSize) {
    const batch = chapterIds.slice(i, i + batchSize);

    const q = query(collection(db, "chapters"), where("__name__", "in", batch));

    const querySnapshot = await getDocs(q);
    querySnapshot.docs.forEach((doc) => {
      const chapterData = doc.data();
      connectedChapters.push({
        id: doc.id,
        userId: chapterData.userId,
        title: chapterData.title,
        startDate: chapterData.startDate.toDate(),
        endDate: chapterData.endDate.toDate(),
        focusAreas: chapterData.focusAreas || [],
        reward: chapterData.reward,
        createdAt: chapterData.createdAt.toDate(),
        updatedAt: chapterData.updatedAt.toDate(),
        doneCount: chapterData.doneCount || 0,
        targetCount: chapterData.targetCount || 0,
        connectedProjects: chapterData.connectedProjects || [],
        retrospective: chapterData.retrospective,
        note: chapterData.note,
      });
    });
  }

  // ÎÇ†ÏßúÏàúÏúºÎ°ú Ï†ïÎ†¨
  connectedChapters.sort(
    (a, b) => a.startDate.getTime() - b.startDate.getTime()
  );

  return connectedChapters;
};

// Ïò§Îäò ÎÇ†ÏßúÏùò taskÎì§ÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
export const getTodayTasks = async (
  userId: string,
  currentChapterId?: string
): Promise<Task[]> => {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    // ÌòÑÏû¨ Ï±ïÌÑ∞Ïùò ÌîÑÎ°úÏ†ùÌä∏Îì§ÏùÑ Î®ºÏ†Ä Í∞ÄÏ†∏Ïò§Í∏∞
    let projectIds: string[] = [];

    if (currentChapterId) {
      // ÌäπÏ†ï Ï±ïÌÑ∞Ïùò ÌîÑÎ°úÏ†ùÌä∏Îì§Îßå
      const projects = await fetchProjectsByChapterId(currentChapterId, userId);
      projectIds = projects.map((p) => p.id);
    } else {
      // ÌòÑÏû¨ ÏßÑÌñâ Ï§ëÏù∏ Ï±ïÌÑ∞Ïùò ÌîÑÎ°úÏ†ùÌä∏Îì§
      const chapters = await fetchAllChaptersByUserId(userId);
      const currentChapter = chapters.find((chapter) => {
        const status = getChapterStatus(chapter);
        return status === "in_progress";
      });

      if (currentChapter) {
        const projects = await fetchProjectsByChapterId(
          currentChapter.id,
          userId
        );
        projectIds = projects.map((p) => p.id);
      }
    }

    if (projectIds.length === 0) {
      return [];
    }

    // Í∞Å ÌîÑÎ°úÏ†ùÌä∏ÏóêÏÑú Ïò§Îäò ÎÇ†ÏßúÏùò taskÎì§ÏùÑ Í∞ÄÏ†∏Ïò§Í∏∞
    const todayTasks: Task[] = [];

    for (const projectId of projectIds) {
      try {
        const tasks = await fetchAllTasksByProjectId(projectId);
        const projectTodayTasks = tasks.filter((task) => {
          const taskDate = new Date(task.date);
          taskDate.setHours(0, 0, 0, 0);
          return taskDate >= today && taskDate < tomorrow;
        });
        todayTasks.push(...projectTodayTasks);
      } catch (error) {
        console.error(`ÌîÑÎ°úÏ†ùÌä∏ ${projectId}Ïùò task Ï°∞Ìöå Ïã§Ìå®:`, error);
      }
    }

    return sortTasksByDateAndTitle(todayTasks);
  } catch (error) {
    console.error("Ïò§Îäò task Ï°∞Ìöå Ïã§Ìå®:", error);
    return [];
  }
};
